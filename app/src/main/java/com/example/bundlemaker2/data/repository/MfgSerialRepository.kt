package com.example.bundlemaker2.data.repository

import com.example.bundlemaker2.data.dao.MfgSerialDao
import com.example.bundlemaker2.data.model.MfgSerialMapping
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.withContext
import javax.inject.Inject

class MfgSerialRepository @Inject constructor(
    private val database: MfgSerialDao
) {
    
    suspend fun saveMfgSerials(mfgId: String, serials: List<String>): Boolean {
        return try {
            val mappings = serials.map { serial ->
                MfgSerialMapping(
                    id = 0, // Auto-generated by Room
                    mfgId = mfgId,
                    serialId = serial,
                    status = "READY",
                    scannedAt = System.currentTimeMillis(),
                    synced = false
                )
            }
            withContext(Dispatchers.IO) {
                insertAll(mappings)
            }
            true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    // Custom repository methods
    suspend fun isSerialExists(serialId: String): Boolean {
        return withContext(Dispatchers.IO) {
            countBySerialId(serialId) > 0
        }
    }
    
    // DAO method implementations with proper coroutine context
    suspend fun getMappingsByMfgId(mfgId: String): Flow<List<MfgSerialMapping>> {
        return withContext(Dispatchers.IO) {
            database.getMappingsByMfgId(mfgId)
        }
    }
    
    suspend fun getUnsyncedMappings(): List<MfgSerialMapping> {
        return withContext(Dispatchers.IO) {
            database.getUnsyncedMappings()
        }
    }
    
    suspend fun markAsSynced(ids: List<Long>) {
        withContext(Dispatchers.IO) {
            database.markAsSynced(ids)
        }
    }
    
    suspend fun getMappingById(id: Long): MfgSerialMapping? {
        return withContext(Dispatchers.IO) {
            // If you need to get by ID, you can add this method to the DAO
            // For now, we'll get all and filter, but this is not efficient for large datasets
            database.getUnsyncedMappings().find { it.id == id }
        }
    }
    
    // Delegate other DAO methods
    suspend fun insert(mapping: MfgSerialMapping): Long = withContext(Dispatchers.IO) { database.insert(mapping) }
    
    suspend fun insertAll(mappings: List<MfgSerialMapping>) = withContext(Dispatchers.IO) { database.insertAll(mappings) }
    
    suspend fun getMapping(mfgId: String, serialId: String) = withContext(Dispatchers.IO) { database.getMapping(mfgId, serialId) }
    
    suspend fun getMappingBySerialId(serialId: String) = withContext(Dispatchers.IO) { database.getMappingBySerialId(serialId) }
    
    suspend fun countByMfgId(mfgId: String) = withContext(Dispatchers.IO) { database.countByMfgId(mfgId) }
    
    suspend fun countBySerialId(serialId: String) = withContext(Dispatchers.IO) { database.countBySerialId(serialId) }
    
    suspend fun update(mapping: MfgSerialMapping) = withContext(Dispatchers.IO) { database.update(mapping) }
    
    suspend fun delete(mapping: MfgSerialMapping) = withContext(Dispatchers.IO) { database.delete(mapping) }
}
